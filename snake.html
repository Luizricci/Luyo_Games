<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake 2-Player</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #87CEEB; /* Azul céu */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            flex-direction: column;
        }

        .game-container {
            position: relative;
            border: 5px solid #000;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            background-color: #70c5ce;
            padding: 20px;
        }

        canvas {
            display: block;
            background-color: #1a1a1a;
            border-radius: 5px;
        }
        
        .score-display {
            position: absolute;
            top: 10px;
            width: 100%;
            display: flex;
            justify-content: space-around;
            text-align: center;
            font-size: 1.5em;
            color: #FFD700;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
        }
        
        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px 60px;
            border-radius: 15px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.7);
            color: #fff;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -40%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        .overlay h2 {
            margin-top: 0;
            color: #FFD700;
            text-shadow: 3px 3px 0 #000;
        }
        
        .countdown {
            font-size: 6em;
            color: #FFD700;
            text-shadow: 5px 5px 0 #000;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .input-group label {
            font-size: 0.8em;
            text-shadow: 1px 1px 0 #000;
        }

        .player-inputs {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .player-input-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-inputs input[type="text"] {
            font-family: 'Press Start 2P', cursive;
            padding: 5px;
            border-radius: 5px;
            border: 2px solid #000;
            background-color: #fff;
            color: #000;
            font-size: 0.8em;
            text-align: center;
        }

        .player-inputs input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 30px;
            height: 30px;
            border: 2px solid #000;
            border-radius: 5px;
            cursor: pointer;
            background: none;
        }

        .start-button, .restart-button, .back-button {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2em;
            padding: 10px 20px;
            border-radius: 10px;
            border: 3px solid #000;
            background-color: #FFD700;
            color: #000;
            cursor: pointer;
            text-shadow: 1px 1px 0 #fff;
            box-shadow: 0 5px 0 #b8860b;
            transition: all 0.1s ease-in-out;
            margin-top: 10px;
        }
        
        .start-button:hover, .restart-button:hover, .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 0 #b8860b;
        }

        .start-button:active, .restart-button:active, .back-button:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 #b8860b;
        }

        .hidden {
            display: none;
        }

        .winner-text {
            font-size: 1.2em;
            color: #FFD700;
            text-shadow: 2px 2px 0 #000;
        }

        .name-tag {
            font-size: 0.6em;
            color: white;
            text-shadow: 1px 1px 0 #000;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        <div id="startOverlay" class="overlay">
            <h2>Snake 1v1</h2>
            <div class="player-inputs">
                <div class="player-input-row">
                    <input type="text" id="player1NameInput" placeholder="Jogador 1 (WASD)">
                    <input type="color" id="player1ColorInput" value="#66FF66">
                </div>
                <div class="player-input-row">
                    <input type="text" id="player2NameInput" placeholder="Jogador 2 (Setas)">
                    <input type="color" id="player2ColorInput" value="#FFD700">
                </div>
            </div>
            <div class="input-group">
                <label for="modeSelector">Modo de Jogo:</label>
                <select id="modeSelector" class="player-inputs input-row" style="padding: 5px; border-radius: 5px; border: 2px solid #000; font-family: 'Press Start 2P', cursive;">
                    <option value="Normal">Normal</option>
                    <option value="Ultra">Ultra</option>
                </select>
            </div>
            <button id="startButton" class="start-button">Iniciar</button>
        </div>
        <div id="countdownOverlay" class="overlay hidden">
            <h2 class="countdown"></h2>
        </div>
        <div id="gameOverOverlay" class="overlay hidden">
            <h2>Fim de Jogo</h2>
            <p id="winnerMessage" class="winner-text">Vencedor: Ninguém</p>
            <button id="restartButton" class="restart-button">Reiniciar</button>
            <button id="backButton" class="back-button">Voltar ao Início</button>
        </div>
        <div id="scoreDisplay" class="score-display hidden">
            <span id="player1ScoreDisplay">P1: 0</span>
            <span id="player2ScoreDisplay">P2: 0</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startOverlay = document.getElementById('startOverlay');
        const countdownOverlay = document.getElementById('countdownOverlay');
        const countdownText = countdownOverlay.querySelector('h2');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const startButton = document.getElementById('startButton');
        const backButton = document.getElementById('backButton');
        const restartButton = document.getElementById('restartButton');
        const winnerMessage = document.getElementById('winnerMessage');
        const player1NameInput = document.getElementById('player1NameInput');
        const player2NameInput = document.getElementById('player2NameInput');
        const player1ColorInput = document.getElementById('player1ColorInput');
        const player2ColorInput = document.getElementById('player2ColorInput');
        const modeSelector = document.getElementById('modeSelector');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const player1ScoreDisplay = document.getElementById('player1ScoreDisplay');
        const player2ScoreDisplay = document.getElementById('player2ScoreDisplay');

        const gridSize = 20;
        const baseFoodCount = 20;
        const baseSpeed = 120; // 120ms is the base speed

        let player1, player2, food, isGameRunning;
        let gameLoopInterval;

        function darkenColor(hex, percent) {
            // function to darken the hex color
            const f = parseInt(hex.slice(1), 16),
                  t = percent < 0 ? 0 : 255,
                  p = percent < 0 ? percent * -1 : percent,
                  R = f >> 16,
                  G = (f >> 8) & 0x00FF,
                  B = f & 0x0000FF;
            return "#" + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
        }

        function initializeGame() {
            const selectedMode = modeSelector.value;
            const foodCount = selectedMode === 'Ultra' ? baseFoodCount * 2 : baseFoodCount;
            const speed = selectedMode === 'Ultra' ? baseSpeed / 2 : baseSpeed;

            player1 = {
                name: player1NameInput.value || "Jogador 1",
                body: [{ x: 5, y: 10 }, { x: 4, y: 10 }, { x: 3, y: 10 }],
                direction: 'right',
                nextDirection: null, // Nova variável para armazenar a próxima direção
                score: 0,
                headColor: player1ColorInput.value,
                bodyColor: darkenColor(player1ColorInput.value, 0.3)
            };

            player2 = {
                name: player2NameInput.value || "Jogador 2",
                body: [{ x: 25, y: 20 }, { x: 26, y: 20 }, { x: 27, y: 20 }],
                direction: 'left',
                nextDirection: null, // Nova variável para armazenar a próxima direção
                score: 0,
                headColor: player2ColorInput.value,
                bodyColor: darkenColor(player2ColorInput.value, 0.3)
            };
            
            food = [];
            isGameRunning = true;
            
            for (let i = 0; i < foodCount; i++) {
                createFood();
            }

            player1ScoreDisplay.textContent = player1.name + ': ' + player1.score;
            player2ScoreDisplay.textContent = player2.name + ': ' + player2.score;
            
            // Show game elements
            startOverlay.classList.add('hidden');
            gameOverOverlay.classList.add('hidden');
            countdownOverlay.classList.add('hidden');
            scoreDisplay.classList.remove('hidden');

            clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(update, speed);
        }

        function startCountdown() {
            // Esconde a tela de game over imediatamente para uma transição suave
            gameOverOverlay.classList.add('hidden'); 
            startOverlay.classList.add('hidden');
            countdownOverlay.classList.remove('hidden');
            let count = 3;
            countdownText.textContent = count;
            
            const timer = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownText.textContent = count;
                } else {
                    clearInterval(timer);
                    initializeGame();
                }
            }, 1000);
        }

        function createFood() {
            let newFood = {};
            let isOverlapping;
            do {
                isOverlapping = false;
                newFood = {
                    x: Math.floor(Math.random() * (canvas.width / gridSize)),
                    y: Math.floor(Math.random() * (canvas.height / gridSize))
                };
                // Check if new food is on a snake or another food
                const allSegments = [...player1.body, ...player2.body, ...food];
                for (let segment of allSegments) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        isOverlapping = true;
                        break;
                    }
                }
            } while (isOverlapping);
            food.push(newFood);
        }

        function drawRoundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function draw() {
            const lightGreen = '#275c36';
            const darkGreen = '#214b2d';
            for (let x = 0; x < canvas.width / gridSize; x++) {
                for (let y = 0; y < canvas.height / gridSize; y++) {
                    ctx.fillStyle = (x + y) % 2 === 0 ? darkGreen : lightGreen;
                    ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                }
            }
            
            food.forEach(f => {
                ctx.fillStyle = '#FF4500';
                ctx.beginPath();
                ctx.arc(f.x * gridSize + gridSize / 2, f.y * gridSize + gridSize / 2, gridSize * 0.45, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#c53800';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(f.x * gridSize + gridSize / 2 - 1, f.y * gridSize - 3, 2, 5);
            });

            [player1, player2].forEach(player => {
                player.body.forEach((segment, index) => {
                    ctx.fillStyle = index === 0 ? player.headColor : player.bodyColor;
                    ctx.strokeStyle = '#228B22';
                    ctx.lineWidth = 2;
                    drawRoundedRect(segment.x * gridSize + 1, segment.y * gridSize + 1, gridSize - 2, gridSize - 2, 5);
                });

                // Draw name tag
                ctx.fillStyle = 'white';
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(player.name, player.body[0].x * gridSize + gridSize / 2, player.body[0].y * gridSize - 5);
            });
        }

        function update() {
            if (!isGameRunning) return;

            // Aplica a próxima direção, se houver
            if (player1.nextDirection) {
                player1.direction = player1.nextDirection;
                player1.nextDirection = null;
            }
            if (player2.nextDirection) {
                player2.direction = player2.nextDirection;
                player2.nextDirection = null;
            }

            const p1Head = { x: player1.body[0].x, y: player1.body[0].y };
            const p2Head = { x: player2.body[0].x, y: player2.body[0].y };

            // Move Player 1
            switch (player1.direction) {
                case 'up': p1Head.y--; break;
                case 'down': p1Head.y++; break;
                case 'left': p1Head.x--; break;
                case 'right': p1Head.x++; break;
            }
            player1.body.unshift(p1Head);

            // Move Player 2
            switch (player2.direction) {
                case 'up': p2Head.y--; break;
                case 'down': p2Head.y++; break;
                case 'left': p2Head.x--; break;
                case 'right': p2Head.x++; break;
            }
            player2.body.unshift(p2Head);

            // Check for food consumption for both players
            let ateFood1 = false;
            let ateFood2 = false;
            food.forEach((f, index) => {
                if (p1Head.x === f.x && p1Head.y === f.y) {
                    player1.score++;
                    player1ScoreDisplay.textContent = player1.name + ': ' + player1.score;
                    food.splice(index, 1);
                    ateFood1 = true;
                }
                if (p2Head.x === f.x && p2Head.y === f.y) {
                    player2.score++;
                    player2ScoreDisplay.textContent = player2.name + ': ' + player2.score;
                    food.splice(index, 1);
                    ateFood2 = true;
                }
            });

            if (!ateFood1) player1.body.pop();
            if (!ateFood2) player2.body.pop();

            // Collision Detection
            const p1Collision = checkCollision(p1Head, player1, player2);
            const p2Collision = checkCollision(p2Head, player2, player1);
            
            // Determina o vencedor com base nas colisões
            const p1Died = p1Collision !== null;
            const p2Died = p2Collision !== null;

            // Se as duas cobras colidirem de forma simultânea (cabeça com cabeça, ou as duas com a parede/corpo)
            // o jogo termina em um empate.
            if ((p1Head.x === p2Head.x && p1Head.y === p2Head.y) || (p1Died && p2Died)) {
                endGame('draw');
            } else if (p1Died) {
                // Se só o jogador 1 morreu, o jogador 2 vence
                endGame('p2_wins');
            } else if (p2Died) {
                // Se só o jogador 2 morreu, o jogador 1 vence
                endGame('p1_wins');
            }

            draw();
        }

        function checkCollision(head, player, opponent) {
            // Wall collision
            if (head.x < 0 || head.x >= canvas.width / gridSize || head.y < 0 || head.y >= canvas.height / gridSize) {
                return 'wall';
            }
            // Self-collision
            for (let i = 1; i < player.body.length; i++) {
                if (head.x === player.body[i].x && head.y === player.body[i].y) {
                    return 'self';
                }
            }
            // Opponent's body collision
            for (let i = 1; i < opponent.body.length; i++) {
                if (head.x === opponent.body[i].x && head.y === opponent.body[i].y) {
                    return 'body';
                }
            }
            return null;
        }

        function endGame(reason) {
            isGameRunning = false;
            clearInterval(gameLoopInterval);
            scoreDisplay.classList.add('hidden');
            gameOverOverlay.classList.remove('hidden');

            let message = '';
            if (reason === 'p1_wins') {
                message = player1.name + ' Venceu!';
            } else if (reason === 'p2_wins') {
                message = player2.name + ' Venceu!';
            } else if (reason === 'draw') {
                message = 'Empate!';
            } else {
                message = 'O jogo acabou!';
            }
            winnerMessage.textContent = message;
        }

        startButton.addEventListener('click', startCountdown);
        restartButton.addEventListener('click', startCountdown);
        backButton.addEventListener('click', () => {
            gameOverOverlay.classList.add('hidden');
            startOverlay.classList.remove('hidden');
            player1NameInput.value = '';
            player2NameInput.value = '';
        });

        window.addEventListener('keydown', e => {
            if (!isGameRunning) return;
            // A lógica abaixo impede que a cobra se mova na direção oposta à sua direção atual.
            // A direção é armazenada em 'nextDirection' e aplicada apenas no próximo "tick" do jogo.

            // Player 1 (WASD)
            switch (e.key) {
                case 'w':
                    if (player1.direction !== 'down') player1.nextDirection = 'up';
                    break;
                case 's':
                    if (player1.direction !== 'up') player1.nextDirection = 'down';
                    break;
                case 'a':
                    if (player1.direction !== 'right') player1.nextDirection = 'left';
                    break;
                case 'd':
                    if (player1.direction !== 'left') player1.nextDirection = 'right';
                    break;
            }
            // Player 2 (Arrow Keys)
            switch (e.key) {
                case 'ArrowUp':
                    if (player2.direction !== 'down') player2.nextDirection = 'up';
                    break;
                case 'ArrowDown':
                    if (player2.direction !== 'up') player2.nextDirection = 'down';
                    break;
                case 'ArrowLeft':
                    if (player2.direction !== 'right') player2.nextDirection = 'left';
                    break;
                case 'ArrowRight':
                    if (player2.direction !== 'left') player2.nextDirection = 'right';
                    break;
            }
        });
        
        window.onload = () => {
            startOverlay.classList.remove('hidden');
        };
    </script>
</body>
</html>
